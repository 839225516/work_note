读书笔记：精通CSS-高级Web标准解决方案
=======================================

第一章：基础知识
-------------------

在写类名和ID名时，需要注意区分大小写，因为浏览器认为.andybudd和.andyBudd是不同的类名。处理这个问题最好的方式是使用统一
的命名约定。为了容易辨认，推荐采用完全小写的类名和ID，多个单词之间用连字符分隔。例如，andy-budd比andyBudd清楚得多。

**div和span**

有助于在文档中添加结构的一个元素是div元素。div实际上代表部分（division），它可以将文档分割为几个有意义的区域。

为了将不必要的标记减少到最少，应该只在没有现有元素能够实现区域分割的情况下使用div元素。例如，如果使用主导航列表，就不需要
将它包围在div中。

::

    <div class="nav">
        <ul>
            <li><a href="/home/">Home</a></li>
            <li><a href="/about/">About</a></li>
            <li><a href="/contact">Contact</a></li>
        </ul>
    </div>

完全可以删除div，直接在列表上应用类。


div可以用来对块级元素进行分组，而span可以用来对行内元素进行分组或标识。


**微格式**


**文档类型、DOCTYPE切换和浏览器模式**

DTD（文档类型定义）是一组机器可读的规则，它们定义XML或HTML的特定版本中允许有什么，不允许有什么。在解析网页时，浏览器将
使用这些规则检查页面的有效性并且采取相应的措施。浏览器通过分析页面的DOCTYPE声明来了解要使用哪个DTD，由此知道要使用HTML的
哪个版本。

DTDTYPE声明是指HTML文档开头处的一行或两行代码，它描述使用哪个DTD。DTDTYPE通常-但不总是-包含指定的DTD文件的URL。例如，
HTML5就不需要URL。浏览器一般不读取这些文件，而是只识别常见的DOCTYPE声明。

DOCTYPE当前有两种风格， *严格*(strict)和 *过渡*(transitional)。顾名思义，过渡DOCTYPE的目的是帮助开发人员从老版本迁移
到新版本。因此，HTML 4.01和XHTML 1.0的过渡版本仍然允许使用已经废弃的元素，比如font元素。


第二章：为样式找到应用目标
----------------------------

2.1 常用的选择器
^^^^^^^^^^^^^^^^^^^

最常用的选择器类型是 **类型选择器** 和 **后代选择器** 。类型选择器用来寻找特定类型的元素。类型选择器有时也称为 **元素选择器** ，
或 **简单选择器** 。

::

    p {color: black;}
    h1 {font-weight: bold;}

后代选择器可用来寻找特定元素或元素组的后代。后代选择器由其他两个选择器之间的空格表示。

::

    blockquote p {padding-left: 2em;}

要想寻找更特定的元素，可以使用ID选择器和类选择器。顾名思义，这两种选择器用于寻找那些具有指定ID或类名的元素。ID选择器由
一个 ``#`` 字符表示，类选择器由一个点号表示。

**伪类**

有时候，我们需要根据文档结构之外的其他条件对元素应用样式，例如表单元素或链接的状态。这要使用伪类选择器来完成。

``:link`` 和 ``:visited`` 称为链接伪类，只能应用于锚元素。 ``:hover`` 、 ``:active`` 和 ``:focus`` 称为动态伪类，理论上
可以应用于任何元素。大多数浏览器都支持这个功能。但是，IE 6只注意应用于锚链接的 ``:active`` 和 ``:hover`` 选择器，完全忽略
``:focus`` 。 IE 7在任何元素上都支持 ``:hover`` ，但是忽略 ``:active`` 和 ``:focus`` 。

另外，通过把伪类连接起来使用，可以创建更复杂的行为，比如在已访问链接和未访问链接上实现不同的鼠标悬停效果。

::

    a:visited:hover {color: olive;}

2.2 通用选择器
^^^^^^^^^^^^^^^^


**相对定位**

如果对一个元素进行相对定位，它将出现在它所在的位置上，然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点移动。
如果将top设置为20像素，那么框将出现在原位置顶部下面20像素的地方。如果将left设置为20像素，那么会在元素左边创建20像素的空间，
也就是将元素向右移动。

::

    #myBox {
        position: relative;
        left: 20px;
        top: 20px;
    }

在使用相对定位时，无论是否移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其他框。

**绝对定位**

相对定位实际上被看作普通流定位模型的一部分，因为元素的位置是相对于它在普通流中位置的。与之相反，绝对定位使元素的位置与
文档流无关，因此不占据空间。普通文档流中其他元素的布局就像绝对定位的元素不存在时一样。

绝对定位的元素的位置是相对于距离它最近的那个已定位的祖先元素确定的。如果元素没有已定位的祖先元素，那么它的位置是相对于
初始包含块的。根据用户代理的不同，初始包含块可能是画布或HTML元素。

与相对定位的框不一样，绝对定位的框可以从它的包含块向上、下、左、右移动。你可以直接将元素定位在页面上的任何位置。

.. note:: 对于定位的主要问题是要记住每种定位的意义。相对定位是“相对于”元素在文档流中的初始位置，而绝对定位是“相对于”距离它最近的已定位祖先元素，如果不存在已定位的祖先元素，那么相对于初始包含块。

因为绝对定位的框与文档流无关，所以它们可以覆盖页面上的其他元素。可以通过设置z-index属性来控制这些框的叠放次序。z-index值
越高，框在栈中的位置就越高。

相对于最近的已定位祖先元素来定位绝对定位的元素，能够实现一些非常有意思的效果。例如，假设希望让一个文本段落对准一个大框的
右下角，只需对包含框进行相对定位，然后相对于这个框对段落进行绝对定位：

::

    #branding {
        width: 70em;
        height: 10em;
        position: relative;
    }

    #branding .tel {
        position: absolute;
        right: 1em;
        bottom: 1em;
        text-align: right;
    }

    <div id="branding">
        <p class="tel">Tel: 0845 838 6163</p>
    </div>

**固定定位**

固定定位时绝对定位的一种。差异在于固定元素的包含块是视口（viewport）。这使我们能够创建总是出现在窗口中相同位置的浮动元素。


**浮动**

浮动的框可以左右移动，直到它的外边缘碰到包含框或另一个浮动框的边缘。因为浮动框不在文档的普通流中，所以文档的普通流中的
块框表现得就像浮动框不存在一样。

**行框和清理**

前一节指出，浮动会让元素脱离文档流，不再影响不浮动的元素。实际上，并不完全如此。如果浮动的元素后面有一个文档流中的元素，
那么这个元素的框会表现得像浮动根本不存在一样。但是，框的文本内容会受到浮动元素的影响，会移动以留出空间。用技术术语来说，
浮动元素旁边的行框被缩短，从而给浮动元素留出空间，因此行框围绕浮动框。

要想阻止行框围绕在浮动框的外边，需要对包含这些行框的元素应用clear属性。clear属性的值可以是left、right、both或none，它表示
框的哪边不应该挨着浮动框。在清理元素时，浏览器在元素顶上添加足够的外边框，使元素的顶边缘垂直下降到浮动框下面。

浮动元素脱离了文档流，不影响周围的元素。但是，对元素进行清理实际上为前面的浮动元素留出了垂直空间。

overflow属性定义了在包含的内容对于指定的尺寸太大的情况下元素应该怎么样。在默认情况下，内容会溢出到框外，进入相邻的空间。
应用值为hidden或auto的overflow属性有一个有用的副作用，这会自动地清理包含的任何浮动元素。因此这是一种有用的元素清理方法，
不需要添加额外的标记。这个方法并不适合所有情况，因为设置框的overflow属性会影响它的表现。更具体地说，这种方法在某些情况下
会产生滚动条或截断内容。


第四章：背景图像效果
-----------------------

CSS使我们能够在页面上显示图像，而不需要让图像成为标记的一部分。实现方法是将图像作为背景添加到现有的元素中。

4.1 背景图像基础
^^^^^^^^^^^^^^^^^^^

如果希望网站有一个好看的背景，那么只需将图像作为背景应用于主体元素：

::

    body {
        background-image:url(/img/pattern.gif);
    }

默认情况下，浏览器水平和垂直地重复显示背景图像，让图像平铺在整个页面上。可以选择背景图像是垂直平铺、水平平铺，
还是根本不平铺。

你可能希望在页面上应用垂直渐变。为此，需要创建一个很高但很窄的渐变图像，然后将这个图像应用于页面的主体并让它水平平铺：

::

    body {
        background-image: url(/img/gradient.gif);
        background-repeat: repeat-x;
    }

因为这个渐变图像的高度是固定的，所以如果页面的内容的长度超过了图像的高度，那么渐变就会突然终止。可以创建一个非常长的图像，
逐渐变化到一个固定的颜色。但是，很难预测页面会有多长。实际上，只需再添加一个背景颜色。背景图像总是出现在背景颜色的上面，
所以当图像结束时，颜色就会显示出来了。如果选择的背景颜色与渐变底部的颜色相同，那么图像和背景颜色之间的转换就看不出来了。

::

    body {
        background-image: url(/img/gradient.gif);
        background-repeat: repeat-x;
        background-color: #ccc;
    }

