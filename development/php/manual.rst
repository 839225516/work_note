
《PHP手册》阅读笔记
======================

基本语法
-------------

**标记**

PHP也允许使用短标记 ``<?`` 和 ``?>`` ，但不鼓励使用。只有通过激活php.ini中 ``short_open_tag`` 配置指令或者在编译PHP时使用了配置选项--enable-short-tags时才能使用短标记。

如果文件内容是纯PHP代码，最好在文件末尾删除PHP结束标记。这可以避免在PHP结束标记之后万一意外加入了空格或者换行符，会导致PHP开始输出这些空白，而脚本中此时并无输出的意图。

**注释**

PHP支持C、C++和Unix Shell风格（ ``#`` ，Perl风格）的注释。


类型
----------

PHP支持8种原始数据类型。四种标量类型：boolean（布尔型）、integer（整型）、float（浮点型，也称作double）、string（字符串）；两种复合类型：array（数组）、object（对象）；最后是两种特殊类型：resource（资源）、NULL（无类型）。

另外还有一些伪类型：

- mixed（混合类型）：mixed 说明一个参数可以接受多种不同的（但不一定是所有的）类型，例如 gettype() 可以接受所有的 PHP 类型， str_replace() 可以接受字符串和数组。
- number（数字类型）：number 说明一个参数可以是integer或者float。
- callback（回调类型）
- void：void 作为返回类型意味着函数的返回值是无用的。void 作为参数列表意味着函数不接受任何参数。

以及伪变量 ``$...`` ：在函数原型中，$... 表示等等的意思。当一个函数可以接受任意个参数时使用此变量名。

*变量的类型通常不是由程序员设定的，确切地说，是由 PHP 根据该变量使用的上下文在运行时决定的。*

如果想查看某个表达式的值和类型，用 ``var_dump`` 函数。

gettype()函数用于查看表达式值的类型。

is_type函数集用于判断表达式值是否为某个特定的类型，如is_int(4)，is_string("Hello World!")。

**Boolean布尔类型**

要指定一个布尔值，使用关键字TRUE或FALSE。两者都不区分大小写。

**Integer整型**

整型值可以使用十进制、十六进制、八进制或二进制（自PHP 5.4.0起可用）表示，前面可以加上可选的符号（-或+）。

要使用八进制表达，数字前必须加上 0（零）。要使用十六进制表达，数字前必须加上 0x。要使用二进制表达，数字前必须加上 0b。

PHP中没有整除的运算符。

**String字符串**

一个字符串 string 就是由一系列的字符组成，其中每个字符等同于一个字节。这意味着 PHP 只能支持 256 的字符集，因此不支持 Unicode。

字符串最大可以达到2GB。

关于字符串的4种形式见： `PHP之道/PHP基础知识/字符串 <http://youngsterxyf.github.io/2013/03/08/php-basics/#id112>`_

当字符串用双引号或 heredoc 结构定义时，其中的变量将会被解析。

string 中的字符可以通过一个从 0 开始的下标，用类似 array 结构中的方括号包含对应的数字来访问和修改，比如 $str[42]。可以把 string 当成字符组成的 array。

字符串可以用 '.'（点）运算符连接起来，注意 '+'（加号）运算符没有这个功能。

PHP中的string的实现方式是一个由字节组成的数组再加上一个整数指明缓冲区长度，并无如何将字节转换成字符的信息，这个过程由程序员决定。字符串由什么值来组成并无限制；特别是值为0（Nul bytes）的字节可以处于字符串的任何位置（不过有几个非“二进制安全”的函数，也许会把NUL字节之后的数据全都忽略）。

由于 PHP 并不特别指明字符串的编码，那字符串到底是怎样编码的呢？例如字符串 "á" 到底是等于 "\xE1"（ISO-8859-1），"\xC3\xA1"（UTF-8，C form），"\x61\xCC\x81"（UTF-8，D form）还是任何其它可能的表达呢？答案是字符串会被按照该脚本文件相同的编码方式来编码。因此如果一个脚本的编码是 ISO-8859-1，则其中的字符串也会被编码为 ISO-8859-1，以此类推。

**Array数组**

PHP中的数组实际上是一个有序映射。映射是一种把values关联到keys的类型。key可以是integer或者string，value可以是任意类型。

此外，key会有如下的强制转换：

- 包含有合法整型值的字符串会被转换为整型。如键名"8"实际会被存储为8.但"08"则不会强制转换，因为其不是一个合法的十进制值。
- 浮点数也会被转换为整型，这意味着其小数部分会被舍去。例如键名8.7实际会存储为8。
- 布尔值也会被转换为整型。即true实际会存储为1,而false会被存储为0。
- Null会被转换为空字符串，即键名null实际会存储为""。
- 数组和对象不能被用为键名。坚持这么做会导致警告：Illegal offset type。

如果在数组定义中多个单元都使用了同一个键名，则只保留最后一个，之前的都会被覆盖。

PHP数组可以同时含有integer和string类型的键名，因为PHP实际上并不区分索引数组和关联数组。

unset() 函数允许删除数组中的某个键。但要注意数组将不会重建索引。如果需要删除后重建索引，可以用 array_values() 函数。

数组(Array) 的赋值总是会涉及到值的拷贝。使用引用运算符通过引用来拷贝数组。示例：::

    <?php
    $arr1 = array(2, 3);
    $arr2 = $arr1;
    $arr2[] = 4;    // $arr2 is changed,
                    // $arr1 is still array(2, 3)

    $arr3 = &$arr1;
    $arr3[] = 4;    // now $arr1 and $arr3 are the same
    ?>

数组是有序的。也可以使用不同的排序函数来改变顺序。可以用 count() 函数来数出数组中元素的个数。

**NULL**

在下列情况下一个变量被认为是 NULL：被赋值为NULL、尚未被赋值、被unset()。


变量
---------

PHP中的变量用一个美元符号后面跟着变量名来表示。一个有效的变量名由字母或者下划线开头，后面跟上任意数量的字母、数字或者下划线。按照正常的正则表达式，可以表述为： ``[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*`` 。

注： ``$this`` 是一个特殊的变量，不能被赋值。

变量默认总是传值赋值。也就是说，当将一个表达式的值赋给一个变量时，整个原始表达式的值被赋值到目标变量。

PHP也提供另一种方式给变量赋值：引用赋值。使用引用赋值，只需简单地将一个 ``&`` 符号加到将要赋值的变量前（源变量）。但要注意：只有有名字的变量可以用于引用赋值。::

    <?php
    $foo = 25;
    $bar = &$foo;   // 合法的赋值
    $bar = &(24 * 7);   // 非法；引用没有名字的表达式结果

    function test()
    {
        return 25;
    }
    $bar = &test(); // 非法
    ?>

虽然在PHP中并不需要初始化变量，但对变量进行初始化是个好习惯。未初始化的变量具有其类型的默认值 --- 布尔类型的变量默认值为FALSE，整型和浮点型变量默认值为零。字符串型变量默认值是空字符串以及数组变量的默认值是空数组。

isset()可以用来检测一个变量是否已被初始化。

PHP中全局变量在函数中使用时必须声明为global。

在全局范围内访问变量的第二个办法是用特殊的PHP自定义 ``$GLOBALS`` 数组。::

    <?php
    $a = 1;
    $b = 2;

    function Sum()
    {
        $GLOBALS['b'] = $GLOBALS['a'] + $GLOBALS['b'];
    }

    Sum();
    echo $b;
    ?>

``$GLOBALS`` 是一个关联数组，每一个变量为一个元素，键名对应变量名，值对应变量的内容。

**静态变量** 仅在局部函数域中存在，但当程序执行离开此作用域时，其值并不丢失。

要写一个不会丢失本次计数值的计数函数，可以使用静态变量。::

    <?php
    function counter()
    {
        static $count = 0;
        echo $a . "\n";
        $a++;
    }

变量$count仅在第一次调用counter()函数时被初始化，之后每次调用counter()函数都会输出$a的值并加一。

静态变量也提供了一种处理递归函数的方法。以下示例中的函数递归计数到10，使用静态变量$count来判断何时停止：::

    <?php
    function test()
    {
        static $count = 0;

        $count++;
        echo $count . "\n";
        if ($count < 10) {
            test();
        }
        $count--;
    }

静态声明是在编译时解析的。

~~~~~~

**可变变量**

有时候使用可变变量是很方便的。也就是一个变量的变量名可以动态地设置和使用。一个可变变量可以获取一个普通变量的值作为自己的变量名：::

    <?php
    $a = 'hello';

    $$a = 'world';

此时，两个变量都被定义了：$a的内容是"hello"，$hello的内容是"world"。

要将可变变量用于数组，必须解决一个模棱两可的问题：当写下$$a[1]时，解析器需要知道是想要$a[1]作为一个变量呢，还是想要$$a作为一个变量并取出该变量中索引为1的值。解决此问题的语法是，对第一种情况使用${$a[1]}，对第二种情况用${$a}[1]。

~~~~~~

可以使用define()函数来定义常量。在PHP 5.3.0以后，可以使用const关键字在类定义外定义常量。一个常量一旦被定义，就不能再改变或者取消定义。

常量只能包含标量数据（boolean, integer, float和string）。

**魔术常量**

PHP向它运行的任何脚本提供了大量的预定义常量。不过很多常量都是由不同的扩展库定义的，只有在加载了这些扩展库时才会出现，或者动态加载后，或者在编译时已经包括进去了。

有八个魔术常量它们的值随着它们在代码中的位置改变而改变。

- __LINE__
- __FILE__
- __DIR__
- __FUNCTION__
- __CLASS__
- __TRAIT__
- __METHOD__
- __NAMESPACE__

运算符
-----------

PHP支持一个错误控制运算符：@。当将其放置在一个PHP表达式之前，该表达式可能产生的任何错误信息都被忽略掉。

如果激活了track_errors特性，表达式产生的任何错误信息都被存放在变量$php_errormsg中。此变量在每次出错时都会被覆盖，所以如果想用它的话就要尽早检查。

~~~~~~

PHP支持一个执行运算符：反引号（``）。PHP将尝试把反引号中的内容作为外壳命令来执行，并将其输出信息返回（可以赋给一个变量而不是简单地丢弃到标准输出）。使用反引号运算符的效果与函数shell_exec()相同。

~~~~~~

有两个字符串运算符：第一个是连接运算符（“.”），它返回其左右参数连接后的字符串；第二个是连接赋值运算符（“.=”）,它将右边参数的值附加到左边的参数值之后。

~~~~~~

**instanceof** 用于确定一个PHP变量是否属于某一类class的实例。

~~~~~~

require和include几乎完全一样，除了处理失败的方式不同之外。require在出错时产生E_COMPILE_ERROR级别的错误。换句话说将导致脚本中止而include只产生警告（E_WARNING），脚本会继续运行。

对于require和include，被包含文件先按参数给出的路径寻找，如果没有给出目录（只有文件名）时则按照include_path指定的目录寻找。如果在include_path下没找到该文件则include最后才在调用该脚本文件所在的目录和当前工作目录下寻找。如果仍未找到文件则include会发出一条警告，而require则发出一个致命错误。

如果定义了路径---不管是绝对路径还是当前目录的相对路径---include_path都会被完全忽略。

当一个文件被包含时，其中所包含的代码继承了include所在行的变量范围。从该处开始，调用文件在该行处可用的任何变量在被调用的文件也都可用。不过所有在包含文件中定义的函数和类都具有全局作用域。

require_once/include_once语句和require/include语句完全相同，唯一的区别是PHP会检查该文件是否已经被包含过，如果是则不会再次包含。


函数
---------
