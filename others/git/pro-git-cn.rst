Pro Git
===========

`英文版 <http://git-scm.com/book>`_ ， `中文版 <http://git-scm.com/book/zh>`_

起步
--------

分布式版本控制系统的客户端并不只是提取最新版本的文件快照，而是把代码仓库完整地镜像下来。
这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。
因此每一次提取操作，实际上都是一次对代码仓库的完整备份。

Git基础
^^^^^^^^^^

**直接记录快照，而非差异比较**

Git和其他版本控制系统的主要差别在于，Git只关心文件数据的整体是否发生变化，而大多数其他系统
则只关心文件内容的具体差异。这类系统（CVS，Subversion，Perforce，Bazaar等）每次记录有哪些文件
作个更新，以及都更新了哪些行的什么内容。如下图所示：

.. image:: /_static/pics/save_diff.png

Git并不保存这些前后变化的差异数据。实际上，Git更像是把变化的文件作快照后，记录在一个微型的文件系统中。
每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这一次快照的索引。
为提高性能，若文件没有变化，Git不会再次保存，而只对上次保存的快照作一链接。Git的工作方式如下图所示：

.. image:: /_static/pics/git_snapshot_way.png

**近乎所有操作都是本地执行**

**时刻保持数据完整性**

在保存到Git之前，所有数据都要进行内容的校验和（checksum）计算，并将结果作为数据的唯一标识和索引。换句话说，
不可能在你修改了文件或目录之后，Git一无所知。所以如果文件在传输时变得不完整，或者磁盘损坏导致文件数据缺失，
Git都能立即察觉。

Git使用SHA-1算法计算数据的校验和，通过对文件的内容或目录的结构计算出一个SHA-1哈希值，作为指纹字符串。该字串
由40个十六进制字符组成。Git的工作完全依赖于这类指纹字符串，所以你会经常看到这样的哈希值。实际上，所有保存在
Git数据库中的东西都是用此哈希值来作索引的，而不是靠文件名。

**多数操作仅添加数据**

**文件的三种状态**

对于任何一个文件，在 Git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。
已提交表示该文件已经被安全地保存在本地数据库中了；已修改表示修改了某个文件，但还没有提交保存；
已暂存表示把已修改的文件放在下次提交时要保存的清单中。

每个项目都有一个 Git 目录（译注：如果 git clone 出来的话，就是其中 .git 的目录；如果 git clone --bare 的话，新建的目录本身就是 Git 目录。），它是 Git 用来保存元数据和对象数据库的地方。该目录非常重要，**每次克隆镜像仓库的时候，实际拷贝的就是这个目录里面的数据**。

从项目中取出某个版本的所有文件和目录，用以开始后续工作的叫做工作目录。这些文件实际上都是从 Git 目录中的压缩对象数据库中提取出来的，接下来就可以在工作目录中对这些文件进行编辑。

所谓的暂存区域只不过是个简单的文件，一般都放在 Git 目录中。有时候人们会把这个文件叫做索引文件，不过标准说法还是叫暂存区域。

安装 Git
^^^^^^^^^^

**从源代码安装**

Git 的工作需要调用 curl，zlib，openssl，expat，libiconv 等库的代码，所以需要先安装这些依赖工具。

初次运行Git前的配置
^^^^^^^^^^^^^^^^^^^^

一般在新的系统上，我们都需要先配置下自己的 Git 工作环境。配置工作只需一次，以后升级时还会沿用现在的配置。当然，如果需要，你随时可以用相同的命令修改已有的配置。

Git 提供了一个叫做 git config 的工具（译注：实际是 ``git-config`` 命令，只不过可以通过 git 加一个名字来呼叫此命令。），专门用来配置或读取相应的工作环境变量。而正是由这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：

- ``/etc/gitconfig`` 文件：系统中对所有用户都普遍适用的配置。若使用 ``git config`` 时用 ``--system`` 选项，读写的就是这个文件。
- ``~/.gitconfig`` 文件：用户目录下的配置文件只适用于该用户。若使用 ``git config`` 时用 ``--global`` 选项，读写的就是这个文件。
- 当前项目的 git 目录中的配置文件（也就是工作目录中的 ``.git/config`` 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 ``.git/config`` 里的配置会覆盖 ``/etc/gitconfig`` 中的同名变量。

在 Windows 系统上，Git 会找寻用户主目录下的 .gitconfig 文件。主目录即 $HOME 变量指定的目录，一般都是 C:\Documents and Settings\$USER。此外，Git 还会尝试找寻 /etc/gitconfig 文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位。

**用户信息**

第一个要配置的是你个人的用户名称和电子邮件地址。这两条配置很重要，每次 Git 提交时都会引用这两条信息，说明是谁提交了更新，所以会随更新内容一起被永久纳入历史记录：

::

    $ git config --global user.name "John Doe"
    $ git config --global user.email johndoe@example.com

如果用了 ``--global`` 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 ``--global`` 选项重新配置即可，新的设定保存在当前项目的 ``.git/config`` 文件里。

**文本编辑器**

Git 需要你输入一些额外消息的时候，会自动调用一个外部文本编辑器给你用。默认会使用操作系统指定的默认编辑器，一般可能会是 Vi 或者 Vim。如果你有其他偏好，比如 Emacs 的话，可以重新设置：

::

    $ git config --global core.editor emacs

**差异分析工具**

在解决合并冲突时使用哪种差异分析工具。比如要改用 vimdiff 的话：

::

    $ git config --global merge.tool vimdiff

Git 可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。当然，你也可以指定使用自己开发的工具。

**查看配置信息**

要检查已有的配置信息，可以使用 ``git config --list`` 命令。

有时候会看到重复的变量名，那就说明它们来自不同的配置文件（比如 /etc/gitconfig 和 ~/.gitconfig），不过最终 Git 实际采用的是最后一个。

也可以直接查阅某个环境变量的设定，只要把特定的名字跟在后面即可，像这样：

::

    $ git config user.name
    Scott Chacon

Git基础
---------

**忽略某些文件**

文件 ``.gitignore`` 的格式规范如下：

- 所有空行或者以注释符号 ``#`` 开头的行都会被Git忽略。
- 可以使用标准的glob模式匹配。
- 匹配模式最后跟反斜杠（ ``/`` ）说明要忽略的是目录。
- 要忽略指定模式以外的文件或目录，可以在模式前加惊叹号（ ``!`` ）取反。

所谓的glob模式是指shell所使用的简化了的正则表达式。星号（ ``*``
）匹配零个或多个任意字符； ``[abc]``
匹配任何一个列在方括号中的字符（这个例子要么匹配一个a，要么匹配一个b，要么匹配一个c）；
问号（ ``?``
）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配。

``.gitignore`` 示例：

::

    # 此为注释 – 将被 Git 忽略
    # 忽略所有 .a 结尾的文件
    *.a
    # 但 lib.a 除外
    !lib.a
    # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO
    /TODO
    # 忽略 build/ 目录下的所有文件
    build/
    # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt
    doc/*.txt

**查看已暂存和未暂存的更新**

要查看尚未暂存的文件更新了哪些部分，不加参数直接输入 ``git diff`` 。

此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没暂存
起来的变化内容。


若要查看已经暂存起来的文件和上次提交时的快照之间的差异，可以用 ``git diff --cached`` 
命令。

**跳过使用暂存区域**

尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。Git提供了
一个跳过使用暂存区域的方式，只要在提交的时候，给 ``git commit`` 加上 ``-a``
选项，Git就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 ``git add``
步骤。

**移除文件**

如果我们想把文件从Git仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。
换句话说，仅是从跟踪清单中删除。比如一些大型日志文件或者一堆 ``.a`` 编译文件，不小心
纳入仓库后，要移除跟踪但不删除文件，以便稍后在 ``.gitignore`` 文件中补上，
用 ``--cached`` 选项即可：

::

    $ git rm --cached readme.txt

后面可以列出文件或者目录的名字，也可以使用glob模式，如：

::

    $ git rm log/\*.log

撤销操作
^^^^^^^^^^^

**修改最后一次提交**

有时候我们提交完了才发现漏掉了几个文件没有加，或者提交信息写错了。想要撤销刚才的提交操作，
可以使用 ``--amend`` 选项重新提交：

::

    $ git commit --amend

此命令将使用当前的暂存区域快照提交。如果刚才提交完没有作任何改动，直接运行此命令
的话，相当于有机会重新编辑提交说明，但将要提交的文件快照和之前的一样。

启动文本编辑器后，会看到上次提交时的说明，编辑它确认没问题后保存退出，就会使用新的
提交说明覆盖刚才失误的提交。

如果刚才提交时忘了暂存某些修改，可以先补上暂存操作，然后再运行 ``--amend``
提交：

::

    $ git commit -m 'initial commit'
    $ git add forgotten_file
    $ git commit --amend

上面的三条命令最终只是产生一个提交，第二个提交命令修正了第一个的提交内容。

**取消已经暂存的文件**

::

    $ git reset HEAD <file>

**取消对文件的修改**

::

    $ git checkout -- <file>

记住，任何已经提交到Git的都可以被恢复。即便在已经删除的分支中的提交，
或者用 ``--amend`` 重新改写的提交，都可以被恢复（关于数据恢复的内容见第九章）。
所以，你可能失去的数据，仅限于没有提交过的，对Git来说它们就像从未存在过一样。

远程仓库的使用
^^^^^^^^^^^^^^^^^^

**查看当前的远程库**

要查看当前配置有哪些远程仓库，可以用 ``git remote``
命令，它会列出每个远程库的简短名字。在克隆完某个项目后，至少可以看到一个名为origin的远程库，
Git默认使用这个名字来标识你所克隆的原始仓库。

也可以加上 ``-v`` 选项，显示对应的克隆地址：

::

    $ git remote -v
    origin  git://github.com/schacon/ticgit.git

**添加远程仓库**

要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用，运行 ``git remote
add [shortname] [url]`` 。

**查看远程仓库信息**

我们可以使用命令 ``git remote show <remote-name>``
来查看某个远程仓库的详细信息。

**远程仓库的删除和重命名**

在新版Git中可以用 ``git remote rename`` 命令修改某个远程仓库在本地的简称，
比如想把 ``pb`` 改成 ``paul`` ，可以这么运行：

::

    $ git remote rename pb paul
    $ git remote
    origin
    paul


碰到远端仓库服务器迁移，或者原来的克隆镜像不再使用，又或者某个参与者不再贡献代码，
那么需要移除对应的远端仓库，可以运行 ``git remote rm`` 命令：

::

    $ git remote rm paul
    $ git remote
    origin


