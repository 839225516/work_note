SQLite
===========

《SQLite权威指南》阅读笔记
----------------------------

.. image:: https://raw.github.com/youngsterxyf/work_note/master/operations/pics/sqlite-1.png

体系结构
^^^^^^^^^^^

SQLite拥有一个简洁的、模块化的体系结构，并引进了一些独特的方法进行关系型数据库管理。
它由可以划分为3个子系统的8个独立模块进行。如下图所示，这些模块将查询过程划分为几
个独立的任务，在体系结构栈的顶部编译查询语句，在中部执行，在底部处理存储并与操作
系统交互。

.. image:: https://raw.github.com/youngsterxyf/work_note/master/operations/pics/sqlite-2.png

**接口**

接口处于栈的顶端，由SQLite C
API组成。程序、脚本语言还有与SQLite交互的库文件最终都是通过它与SQLite交互的。

**编译器**

编译过程从词法分析器（Tokenizer）和语法分析器（Parser）开始。它们协同处理文本形式
的结构化查询语言（SQL），分析其语法有效性，然后转化为底层能更方便地处理的层次化
数据结构。SQL语句先被分解成一个个词法记号，经过评估后以语法树形式重组，然后语法分析器
将该树下传给代码生成器。

代码生成器将语法树翻译成一种SQLite专用的汇编代码，这些汇编代码由一些最终由虚拟机执行
的指令组成。代码生成器的唯一工作是将语法树转换为完全由这种汇编语言编写的微程序并交给虚拟机处理。

**虚拟机**

体系结构栈的中心部分是虚拟机，也叫虚拟数据库引擎（Virtual Database Engine，VDBE）。

SQLite的特性
^^^^^^^^^^^^^^

SQLite的冲突解决功能内建在许多SQL操作中，可以用来执行称为“惰性更新”的操作。假设有
一个记录需要插入，但是您不确定数据库中是否已经存在一个了。可以不用先写SELECT语句去
查询，如果存在，就将您的INSERT语句重新改写成UPDATE语句，冲突解决可以帮助您。“试图
插入该记录，如果发现相同主键的记录，就更新该记录”。现在就可以将必须写三个不同的SQL
语句（例如，SELECT、INSERT，以及可能的UPDATE）转换成一个INSERT ON
REPLACE(...)语句。

SQLite可以将外部数据库“附着”到当前连接中。假如你当前连接到一个数据库foo.db，同时
需要另外一个数据库bar.db工作。不用打开一个单独的连接，然后在它们之间来回切换，可以
简单地将感兴趣的数据库用下面的一个SQL语句附着到当前连接：

::

    ATTACH database bar.db as bar;

bar.db中所有的表现在读可以访问了，就好像它们存在于foo.db中一样，完成时也可以剥离。
这使得在数据库之间的各种操作如同复制表一样容易。

性能和限制
^^^^^^^^^^^^^

在对单表进行查询时，平均而言，SQLite与其他数据库一样快（至少不慢于）。简单的SELECT、
INSERT和UPDATE语句是相当快速的---几乎与内存（如果是内存数据库）或者磁盘同速。SQLite
通常要快于其他数据库，因为它在处理一个事务开始，或者一个查询计划的产生方面开销较小，
并且没有调用服务器的网络或认证以及权限协商的开销。它的简单性使它更快。

但是随着查询变大变复杂，查询时间使得网络调用或者事务处理开销相形见绌，SQLite将会与
其他数据库一样，这时一些大型的设计复杂的数据库开始发挥作用。虽然SQLite也能处理复杂的
查询，但是它没有精密的优化器或者查询计划器。SQLite知道如何使用索引，但是它没有保存
详细的表统计信息。
